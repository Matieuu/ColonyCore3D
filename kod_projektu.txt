

========================================
PLIK: ./main/shader.frag
========================================
#version 330 core
out vec4 FragColor;

in vec3 vColor;

void main() {
    FragColor = vec4(vColor, 1.0);
}

========================================
PLIK: ./main/Program.cs
========================================
namespace ColonyCore {
    class Program {
        static void Main(string[] args) {
            var _ = new ColonyCore();
        }
    }
}

========================================
PLIK: ./main/src/render/Shader.cs
========================================
using Silk.NET.OpenGL;
using Silk.NET.Maths;

namespace ColonyCore;

public class Shader : IDisposable {

    private Dictionary<string, int> _uniformLocations = new Dictionary<string, int>();

    private uint _handle;
    private GL _gl;

    public Shader(GL gl, string vertexPath, string fragmentPath) {
        _gl = gl;

        uint vertex = LoadShader(ShaderType.VertexShader, vertexPath);
        uint fragment = LoadShader(ShaderType.FragmentShader, fragmentPath);
        _handle = _gl.CreateProgram();
        _gl.AttachShader(_handle, vertex);
        _gl.AttachShader(_handle, fragment);
        _gl.LinkProgram(_handle);
        _gl.GetProgram(_handle, GLEnum.LinkStatus, out var status);
        if (status == 0) {
            throw new Exception($"Program failed to link with error: {_gl.GetProgramInfoLog(_handle)}");
        }
        _gl.DetachShader(_handle, vertex);
        _gl.DetachShader(_handle, fragment);
        _gl.DeleteShader(vertex);
        _gl.DeleteShader(fragment);
    }

    public void Use() {
        _gl.UseProgram(_handle);
    }

    private int GetUniformLocation(string name) {
        if (_uniformLocations.TryGetValue(name, out int location)) {
            return location;
        }

        location = _gl.GetUniformLocation(_handle, name);
        if (location == -1) {
            Console.WriteLine($"[Warning] Uniform {name} does not exist or is not in use");
        }

        _uniformLocations.Add(name, location);
        return location;
    }

    public void SetUniform(string name, int value) {
        int location = GetUniformLocation(name);
        if (location == -1) {
            throw new Exception($"{name} uniform not found on shader.");
        }
        _gl.Uniform1(location, value);
    }

    public void SetUniform(string name, float value) {
        int location = GetUniformLocation(name);
        if (location == -1) {
            throw new Exception($"{name} uniform not found on shader.");
        }
        _gl.Uniform1(location, value);
    }

    public void SetUniform(string name, Vector2D<float> value) {
        int location = GetUniformLocation(name);
        if (location == -1) {
            throw new Exception($"{name} uniform not found on shader.");
        }
        _gl.Uniform2(location, value.X, value.Y);
    }

    public unsafe void SetUniform(string name, Vector3D<float> value) {
        int location = GetUniformLocation(name);
        if (location == -1) {
            throw new Exception($"{name} uniform not found on shader.");
        }
        _gl.Uniform3(location, value.X, value.Y, value.Z);
    }

    public unsafe void SetUniform(string name, Matrix4X4<float> value) {
        int location = GetUniformLocation(name);
        if (location == -1) {
            throw new Exception($"{name} uniform not found on shader.");
        }
        _gl.UniformMatrix4(location, 1, false, (float*)&value);
    }

    public void Dispose() {
        _gl.DeleteProgram(_handle);
    }

    private uint LoadShader(ShaderType type, string path) {
        string src = File.ReadAllText(path);
        uint handle = _gl.CreateShader(type);
        _gl.ShaderSource(handle, src);
        _gl.CompileShader(handle);
        string infoLog = _gl.GetShaderInfoLog(handle);
        if (!string.IsNullOrWhiteSpace(infoLog)) {
            throw new Exception($"Error compiling shader of type {type}, failed with error {infoLog}");
        }

        return handle;
    }

}


========================================
PLIK: ./main/src/render/Camera.cs
========================================
using Silk.NET.Maths;

namespace ColonyCore;

public class Camera {

    public Vector3D<float> Position { get; private set; }
    public Vector3D<float> Target { get; private set; }

    public Matrix4X4<float> ViewMatrix { get; private set; }
    public Matrix4X4<float> ProjectionMatrix { get; private set; }

    private Vector3D<float> _up = Vector3D<float>.UnitY;

    private float _zoom = 50f;
    private float _aspectRatio;
    private float _yaw = 45f;
    private float _pitch = -35f;

    public Camera(float width, float height) {
        Position = new Vector3D<float>(100, 50, 100);
        _aspectRatio = width / height;
        UpdateMatrices();
    }

    public void UpdateAspectRatio(float width, float height) {
        _aspectRatio = width / height;
        UpdateMatrices();
    }

    public void Move(Vector3D<float> delta) {
        Position += delta;
        UpdateMatrices();
    }

    public void Zoom(float delta) {
        _zoom = Math.Clamp(_zoom - delta, 5f, 100f);
        UpdateMatrices();
    }

    public void Rotate(float deltaX, float deltaY) {
        _yaw += deltaX;
        _pitch += deltaY;
        UpdateMatrices();
    }

    public void Pan(float deltaX, float deltaZ) {
        float sensitivity = .002f * _zoom;

        var forward = Vector3D.Normalize(Target - Position);
        forward.Y = 0;
        forward = Vector3D.Normalize(forward);

        var right = Vector3D.Normalize(Vector3D.Cross(forward, _up));

        var moveVector = (right * deltaX * sensitivity) + (forward * -deltaZ * sensitivity);

        Target += moveVector;
        UpdateMatrices();
    }

    private void UpdateMatrices() {
        if (_yaw > 360f) _yaw -= 360f;
        else if (_yaw < 0f) _yaw += 360f;
        _pitch = Math.Clamp(_pitch, -90f, 0f);

        float yawRad = _yaw * (MathF.PI / 180f);
        float pitchRad = _pitch * (MathF.PI / 180f);
        float distance = 200f;

        float x = distance * MathF.Cos(pitchRad) * MathF.Sin(yawRad);
        float y = distance * MathF.Sin(MathF.Abs(pitchRad));
        float z = distance * MathF.Cos(pitchRad) * MathF.Cos(yawRad);

        Position = Target + new Vector3D<float>(x, y, z);
        ViewMatrix = Matrix4X4.CreateLookAt(Position, Target, _up);

        float orthoWidth = _zoom * _aspectRatio;
        float orthoHeight = _zoom;

        ProjectionMatrix = Matrix4X4.CreateOrthographic(orthoWidth, orthoHeight, .1f, 2000f);
    }

}


========================================
PLIK: ./main/src/render/VertexArrayObject.cs
========================================
using Silk.NET.OpenGL;

namespace ColonyCore;

public class VertexArrayObject<TType, TIndex> : IDisposable
    where TType : unmanaged
    where TIndex : unmanaged {

    private uint _handle;
    private GL _gl;

    public VertexArrayObject(GL gl, BufferObject<TType> vbo, BufferObject<TIndex> ebo = null!) {
        _gl = gl;
        _handle = _gl.GenVertexArray();
        Bind();

        // VAO musi wiedzieć, z jakiego VBO ma czytać przepis
        vbo.Bind();
        ebo?.Bind();
    }

    public unsafe void VertexAttributePointer(uint index, int count, VertexAttribPointerType type, uint stride, int offset) {
        // Tu jest ta cała matematyka sizeof, której nie chcesz widzieć w Main
        _gl.VertexAttribPointer(index, count, type, false, stride * (uint)sizeof(TType), (void*)(offset * sizeof(TType)));
        _gl.EnableVertexAttribArray(index);
    }

    public void Bind() {
        _gl.BindVertexArray(_handle);
    }

    public void Dispose() {
        _gl.DeleteVertexArray(_handle);
    }

}

========================================
PLIK: ./main/src/render/BufferObject.cs
========================================
using Silk.NET.OpenGL;

namespace ColonyCore;

// T musi być "unmanaged" (typem prostym: float, int, struct), żeby wskaźniki działały
public class BufferObject<T> : IDisposable where T : unmanaged {

    private uint _handle;
    private BufferTargetARB _bufferType;
    private GL _gl;

    public unsafe BufferObject(
        GL gl,
        Span<T> data,
        BufferTargetARB bufferType,
        BufferUsageARB bufferUsage = BufferUsageARB.StaticDraw
    ) {
        _gl = gl;
        _bufferType = bufferType;

        _handle = _gl.GenBuffer();
        Bind();

        // Magia wskaźników zamknięta w środku
        fixed (void* d = data) {
            _gl.BufferData(bufferType, (nuint)(data.Length * sizeof(T)), d, bufferUsage);
        }
    }

    public void Bind() {
        _gl.BindBuffer(_bufferType, _handle);
    }

    public void Dispose() {
        _gl.DeleteBuffer(_handle);
    }

}

========================================
PLIK: ./main/src/ColonyCore.cs
========================================
using System.Drawing;
using System.Numerics;
using Silk.NET.Input;
using Silk.NET.Maths;
using Silk.NET.OpenGL;
using Silk.NET.OpenGL.Extensions.ImGui;
using Silk.NET.Windowing;

namespace ColonyCore;

class ColonyCore {

    private readonly IWindow _window;
    private IKeyboard _keyboard = null!;
    private IMouse _mouse = null!;

    private GL _gl = null!;
    private IInputContext _input = null!;
    private ImGuiController _controller = null!;
    private Shader _shader = null!;

    private IntPtr _simHandle = IntPtr.Zero;
    private Camera _camera = null!;
    private World _world = null!;

    private Vector2 _lastMousePos = Vector2.Zero;

    public ColonyCore() {
        _window = Window.Create(WindowOptions.Default with {
            Title = "Colony Core 3D",
            Size = new Vector2D<int>(1600, 900),
            VSync = true
        });

        _window.Load += OnLoad;
        _window.Update += OnUpdate;
        _window.Render += OnRender;
        _window.Closing += OnClose;

        _window.Run();
    }

    private void OnLoad() {
        _gl = _window.CreateOpenGL();
        _input = _window.CreateInput();
        _controller = new ImGuiController(_gl, _window, _input);
        _shader = new Shader(_gl, "shader.vert", "shader.frag");

        _keyboard = _input.Keyboards[0];
        _mouse = _input.Mice[0];

        _mouse.Scroll += OnScroll;
        _mouse.MouseDown += OnMouseDown;
        _mouse.MouseMove += OnMouseMove;

        _simHandle = NativeLib.Sim_Init(100, 20, 100);
        _camera = new Camera(_window.Size.X, _window.Size.Y);
        _world = new World(_gl, _simHandle);

        _gl.Enable(EnableCap.DepthTest);
        // _gl.Disable(EnableCap.CullFace);
    }

    private void OnUpdate(double deltaTime) {
        NativeLib.Sim_Tick(_simHandle);

        float keySpeed = 20f * (float)deltaTime;
        if (_keyboard.IsKeyPressed(Key.W)) _camera.Pan(0, keySpeed);
        if (_keyboard.IsKeyPressed(Key.S)) _camera.Pan(0, -keySpeed);
        if (_keyboard.IsKeyPressed(Key.A)) _camera.Pan(keySpeed, 0);
        if (_keyboard.IsKeyPressed(Key.D)) _camera.Pan(-keySpeed, 0);

        float rotSpeed = 90f * (float)deltaTime;
        if (_keyboard.IsKeyPressed(Key.Q)) _camera.Rotate(rotSpeed, 0);
        if (_keyboard.IsKeyPressed(Key.E)) _camera.Rotate(-rotSpeed, 0);

        _controller.Update((float)deltaTime);
    }

    private void OnRender(double deltaTime) {
        _gl.ClearColor(Color.CornflowerBlue);
        _gl.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);

        _shader.Use();
        _shader.SetUniform("uView", _camera.ViewMatrix);
        _shader.SetUniform("uProjection", _camera.ProjectionMatrix);

        _world.Render();
        _controller.Render();
    }

    private void OnClose() {
        _world.Dispose();
        NativeLib.Sim_Destroy(_simHandle);
        _shader.Dispose();
        _controller.Dispose();
        _input.Dispose();
        _gl.Dispose();
    }

    private void OnScroll(IMouse mouse, ScrollWheel wheel) {
        _camera.Zoom(wheel.Y * 5f);
    }

    private void OnMouseDown(IMouse mouse, MouseButton button) {
        if (button == MouseButton.Middle || button == MouseButton.Right) {
            _lastMousePos = mouse.Position;
        }
    }

    private void OnMouseMove(IMouse mouse, Vector2 pos) {
        var delta = _lastMousePos - pos;

        if (mouse.IsButtonPressed(MouseButton.Left)) {
            _camera.Pan(delta.X, delta.Y);
        }

        if (mouse.IsButtonPressed(MouseButton.Right)) {
            _camera.Rotate(delta.X, delta.Y);
        }

        _lastMousePos = pos;
    }

}


========================================
PLIK: ./main/src/objects/World.cs
========================================
using Silk.NET.OpenGL;

namespace ColonyCore;

public class World {

    private readonly float[] CUBE_VERTICES = {
        // X, Y, Z,           R, G, B
        // Ściana Przednia
        -0.5f, -0.5f,  0.5f,  0.6f, 0.6f, 0.6f,
         0.5f, -0.5f,  0.5f,  0.6f, 0.6f, 0.6f,
         0.5f,  0.5f,  0.5f,  0.6f, 0.6f, 0.6f,
         0.5f,  0.5f,  0.5f,  0.6f, 0.6f, 0.6f,
        -0.5f,  0.5f,  0.5f,  0.6f, 0.6f, 0.6f,
        -0.5f, -0.5f,  0.5f,  0.6f, 0.6f, 0.6f,

        // Ściana Tylna
        -0.5f, -0.5f, -0.5f,  0.4f, 0.4f, 0.4f,
         0.5f, -0.5f, -0.5f,  0.4f, 0.4f, 0.4f,
         0.5f,  0.5f, -0.5f,  0.4f, 0.4f, 0.4f,
         0.5f,  0.5f, -0.5f,  0.4f, 0.4f, 0.4f,
        -0.5f,  0.5f, -0.5f,  0.4f, 0.4f, 0.4f,
        -0.5f, -0.5f, -0.5f,  0.4f, 0.4f, 0.4f,

        // Ściana Lewa
        -0.5f,  0.5f,  0.5f,  0.5f, 0.5f, 0.5f,
        -0.5f,  0.5f, -0.5f,  0.5f, 0.5f, 0.5f,
        -0.5f, -0.5f, -0.5f,  0.5f, 0.5f, 0.5f,
        -0.5f, -0.5f, -0.5f,  0.5f, 0.5f, 0.5f,
        -0.5f, -0.5f,  0.5f,  0.5f, 0.5f, 0.5f,
        -0.5f,  0.5f,  0.5f,  0.5f, 0.5f, 0.5f,

        // Ściana Prawa
         0.5f,  0.5f,  0.5f,  0.7f, 0.7f, 0.7f,
         0.5f,  0.5f, -0.5f,  0.7f, 0.7f, 0.7f,
         0.5f, -0.5f, -0.5f,  0.7f, 0.7f, 0.7f,
         0.5f, -0.5f, -0.5f,  0.7f, 0.7f, 0.7f,
         0.5f, -0.5f,  0.5f,  0.7f, 0.7f, 0.7f,
         0.5f,  0.5f,  0.5f,  0.7f, 0.7f, 0.7f,

        // Ściana Dolna
        -0.5f, -0.5f, -0.5f,  0.3f, 0.3f, 0.3f,
         0.5f, -0.5f, -0.5f,  0.3f, 0.3f, 0.3f,
         0.5f, -0.5f,  0.5f,  0.3f, 0.3f, 0.3f,
         0.5f, -0.5f,  0.5f,  0.3f, 0.3f, 0.3f,
        -0.5f, -0.5f,  0.5f,  0.3f, 0.3f, 0.3f,
        -0.5f, -0.5f, -0.5f,  0.3f, 0.3f, 0.3f,

        // Ściana Górna
        -0.5f,  0.5f, -0.5f,  0.8f, 0.8f, 0.8f,
         0.5f,  0.5f, -0.5f,  0.8f, 0.8f, 0.8f,
         0.5f,  0.5f,  0.5f,  0.8f, 0.8f, 0.8f,
         0.5f,  0.5f,  0.5f,  0.8f, 0.8f, 0.8f,
        -0.5f,  0.5f,  0.5f,  0.8f, 0.8f, 0.8f,
        -0.5f,  0.5f, -0.5f,  0.8f, 0.8f, 0.8f
    };

    private GL _gl;
    private IntPtr _simHandle;

    private BufferObject<float> _vbo;
    private BufferObject<float> _instanceVbo;
    private VertexArrayObject<float, uint> _vao;

    public World(GL gl, IntPtr simHandle) {
        _gl = gl;
        _simHandle = simHandle;

        _vbo = new BufferObject<float>(_gl, CUBE_VERTICES, BufferTargetARB.ArrayBuffer);
        _instanceVbo = new BufferObject<float>(_gl, new float[30_000], BufferTargetARB.ArrayBuffer, BufferUsageARB.DynamicDraw);
        _vao = new VertexArrayObject<float, uint>(_gl, _vbo);

        _vao.VertexAttributePointer(0, 3, VertexAttribPointerType.Float, 6, 0);
        _vao.VertexAttributePointer(1, 3, VertexAttribPointerType.Float, 6, 3);

        _instanceVbo.Bind();
        unsafe {
            _gl.EnableVertexAttribArray(2);
            _gl.VertexAttribPointer(2, 3, VertexAttribPointerType.Float, false, 3 * sizeof(float), null);
            _gl.VertexAttribDivisor(2, 1);
        }
    }

    public void Render() {
        IntPtr mapPtr = NativeLib.Sim_GetMapPtr(_simHandle);
        ulong mapLen = NativeLib.Sim_GetMapLen(_simHandle);
        uint width = NativeLib.World_GetWidth(_simHandle);
        uint height = NativeLib.World_GetHeight(_simHandle);
        uint depth = NativeLib.World_GetDepth(_simHandle);

        var instancePositions = new List<float>();

        unsafe {
            ushort* map = (ushort*)mapPtr;

            for (uint y = 0; y < height; y++)
                for (uint z = 0; z < depth; z++)
                    for (uint x = 0; x < width; x++) {
                        long idx = x + (y * width) + (z * width * height);
                        if (map[idx] != 0) {
                            instancePositions.Add(x);
                            instancePositions.Add(y);
                            instancePositions.Add(z);
                        }
                    }
        }

        _instanceVbo.Bind();
        unsafe {
            fixed (float* d = instancePositions.ToArray()) {
                _gl.BufferSubData(BufferTargetARB.ArrayBuffer, 0, (nuint)(instancePositions.Count * sizeof(float)), d);
            }
        }

        _vao.Bind();
        unsafe {
            _gl.DrawArraysInstanced(PrimitiveType.Triangles, 0, 36, (uint)(instancePositions.Count / 3));
        }
    }

    public void Dispose() {
        _instanceVbo.Dispose();
        _vbo.Dispose();
        _vao.Dispose();
    }

}


========================================
PLIK: ./main/src/NativeLib.cs
========================================
using System.Reflection;
using System.Runtime.InteropServices;

namespace ColonyCore;

public static partial class NativeLib {

    private const string LibName = "brain";

    static NativeLib() {
        NativeLibrary.SetDllImportResolver(Assembly.GetExecutingAssembly(), DllImportResolver);
    }

    private static IntPtr DllImportResolver(string libraryName, Assembly assembly, DllImportSearchPath? searchPath) {
        if (libraryName == LibName) {
            if (OperatingSystem.IsWindows()) {
                return NativeLibrary.Load(LibName + ".dll", assembly, searchPath);
            }
            else if (OperatingSystem.IsLinux()) {
                return NativeLibrary.Load("lib" + LibName + ".so", assembly, searchPath);
            }
            else if (OperatingSystem.IsMacOS()) {
                return NativeLibrary.Load("lib" + LibName + ".dylib", assembly, searchPath);
            }
        }

        return IntPtr.Zero;
    }

    [LibraryImport(LibName, EntryPoint = "sim_init")]
    public static partial IntPtr Sim_Init(uint x, uint y, uint z);

    [LibraryImport(LibName, EntryPoint = "sim_destroy")]
    public static partial void Sim_Destroy(IntPtr ptr);

    [LibraryImport(LibName, EntryPoint = "world_get_width")]
    public static partial uint World_GetWidth(IntPtr ptr);

    [LibraryImport(LibName, EntryPoint = "world_get_height")]
    public static partial uint World_GetHeight(IntPtr ptr);

    [LibraryImport(LibName, EntryPoint = "world_get_depth")]
    public static partial uint World_GetDepth(IntPtr ptr);

    [LibraryImport(LibName, EntryPoint = "sim_get_map_ptr")]
    public static partial IntPtr Sim_GetMapPtr(IntPtr ptr);

    [LibraryImport(LibName, EntryPoint = "sim_get_map_len")]
    public static partial ulong Sim_GetMapLen(IntPtr ptr);

    [LibraryImport(LibName, EntryPoint = "sim_entity_get_float")]
    public static partial byte Sim_TryGetEntityFloat(IntPtr ptr, uint x, uint y, uint z, ushort propId, out float out_value);

    [LibraryImport(LibName, EntryPoint = "sim_entity_get_int")]
    public static partial byte Sim_TryGetEntityInt(IntPtr ptr, uint x, uint y, uint z, ushort propId, out int out_value);

    [LibraryImport(LibName, EntryPoint = "sim_tick")]
    public static partial void Sim_Tick(IntPtr ptr);

}


========================================
PLIK: ./main/src/Constants.cs
========================================
public static class Constants {

    public const ushort PROP_FUEL_LEVEL = 1;
    public const ushort PROP_MAX_FUEL = 2;

    public const ushort PROP_IS_ACTIVE = 100;
    public const ushort PROP_ITEM_COUNT = 101;

}


========================================
PLIK: ./main/shader.vert
========================================
#version 330 core

layout (location = 0) in vec3 aPos;
layout (location = 1) in vec3 aColor;
layout (location = 2) in vec3 aInstancePos;

uniform mat4 uView;
uniform mat4 uProjection;

out vec3 vColor;

void main() {
    vec3 worldPos = aPos + aInstancePos;

    gl_Position = uProjection * uView * vec4(worldPos, 1.0);
    vColor = aColor;
}

========================================
PLIK: ./main/main.csproj
========================================
﻿<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net10.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Silk.NET.Input" Version="2.22.0" />
    <PackageReference Include="Silk.NET.OpenGL" Version="2.22.0" />
    <PackageReference Include="Silk.NET.OpenGL.Extensions.ImGui" Version="2.22.0" />
    <PackageReference Include="Silk.NET.Windowing" Version="2.22.0" />
    <PackageReference Include="StbImageSharp" Version="2.30.15" />
  </ItemGroup>

  <ItemGroup>
    <None Update="shader.vert">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </None>
    <None Update="shader.frag">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </None>
</ItemGroup>

</Project>


========================================
PLIK: ./brain/Cargo.toml
========================================
[package]
name = "brain"
version = "0.1.0"
edition = "2024"

[lib]
crate-type = ["cdylib"]

[dependencies]


========================================
PLIK: ./brain/src/block_entity.rs
========================================
pub trait BlockEntity {
    #[rustfmt::skip]    fn get_float(&self, id: u16) -> Option<f32> { None }
    #[rustfmt::skip]    fn get_int(&self, id: u16) -> Option<i32> { None }

    fn set_float(&mut self, id: u16, value: f32) {}
    fn set_int(&mut self, id: u16, value: i32) {}

    fn tick(&mut self) {}
}


========================================
PLIK: ./brain/src/utils.rs
========================================
pub fn is_int_boolean(value: i32) -> bool {
    value == 0 || value == 1
}

pub fn is_int_positive(value: i32) -> bool {
    value >= 0
}


========================================
PLIK: ./brain/src/lib.rs
========================================
#![warn(clippy::all, clippy::pedantic)]
#![forbid(clippy::unwrap_used, clippy::ok_expect, clippy::err_expect)]
#![deny(
    unused_must_use,
    unreachable_patterns,
    unused_variables,
    rust_2018_idioms
)]
#![allow(clippy::module_name_repetitions)]
#![cfg_attr(
    debug_assertions,
    allow(dead_code, unused_imports, unused_mut, unused_variables)
)]
#![cfg_attr(not(debug_assertions), deny(debug_assertions))]

use std::collections::HashMap;

use crate::{machines::furnace::Furnace, world::World};

pub mod block_entity;
pub mod constants;
pub mod machines;
pub mod utils;
pub mod world;

#[unsafe(no_mangle)]
pub extern "C" fn sim_init(x: u32, y: u32, z: u32) -> *mut World {
    let world_size = x * y * z;

    let mut world = Box::new(World {
        width: x,
        height: y,
        depth: z,
        map: vec![0; world_size as usize],
        entities: HashMap::with_capacity((world_size as f32).sqrt().floor() as usize),
    });

    for dx in 0..x {
        for dz in 0..z {
            if let Some(idx) = world.calc_index(dx, 0, dz) {
                world.map[idx] = 1;
            }
        }
    }

    if let Some(idx) = world.calc_index(10, 1, 10) {
        use crate::machines::furnace;
        let mut furnace = Furnace {
            fuel_level: 50.0,
            max_fuel_level: 100.0,
        };

        world.entities.insert(idx, Box::new(furnace));
    }

    Box::into_raw(world)
}

#[unsafe(no_mangle)]
pub extern "C" fn world_get_width(world: *const World) -> u32 {
    let world = unsafe { &*world };
    world.width
}

#[unsafe(no_mangle)]
pub extern "C" fn world_get_height(world: *const World) -> u32 {
    let world = unsafe { &*world };
    world.height
}

#[unsafe(no_mangle)]
pub extern "C" fn world_get_depth(world: *const World) -> u32 {
    let world = unsafe { &*world };
    world.depth
}

#[unsafe(no_mangle)]
pub extern "C" fn sim_destroy(ptr: *mut World) {
    let _ = unsafe { Box::from_raw(ptr) };
}

#[unsafe(no_mangle)]
pub extern "C" fn sim_get_map_ptr(ptr: *mut World) -> *const u16 {
    let world = unsafe { &mut *ptr };
    world.map.as_ptr()
}

#[unsafe(no_mangle)]
pub extern "C" fn sim_get_map_len(ptr: *mut World) -> u64 {
    let world = unsafe { &mut *ptr };
    world.map.len() as u64
}

#[unsafe(no_mangle)]
pub extern "C" fn sim_entity_get_float(
    ptr: *mut World,
    x: u32,
    y: u32,
    z: u32,
    prop_id: u16,
    out_value: *mut f32,
) -> u8 {
    let world = unsafe { &mut *ptr };

    if let Some(idx) = world.calc_index(x, y, z) {
        if let Some(entity) = world.entities.get(&idx) {
            if let Some(val) = entity.get_float(prop_id) {
                unsafe { *out_value = val }
                return 1;
            }
        }
    }

    0
}

#[unsafe(no_mangle)]
pub extern "C" fn sim_entity_get_int(
    ptr: *mut World,
    x: u32,
    y: u32,
    z: u32,
    prop_id: u16,
    out_value: *mut i32,
) -> u8 {
    let world = unsafe { &mut *ptr };

    if let Some(idx) = world.calc_index(x, y, z) {
        if let Some(entity) = world.entities.get(&idx) {
            if let Some(val) = entity.get_int(prop_id) {
                unsafe { *out_value = val }
                return 1;
            }
        }
    }

    0
}

#[unsafe(no_mangle)]
pub extern "C" fn sim_tick(ptr: *mut World) {
    let world = unsafe { &mut *ptr };

    for (_, entity) in world.entities.iter_mut() {
        entity.tick();
    }
}


========================================
PLIK: ./brain/src/world.rs
========================================
use std::{collections::HashMap, u32};

use crate::block_entity::BlockEntity;

pub struct World {
    pub width: u32,
    pub height: u32,
    pub depth: u32,

    pub map: Vec<u16>,
    pub entities: HashMap<usize, Box<dyn BlockEntity>>,
}

impl World {
    pub fn calc_index(&self, x: u32, y: u32, z: u32) -> Option<usize> {
        if x >= self.width || y >= self.height || z >= self.depth {
            return None;
        }

        let idx: usize = x as usize
            + y as usize * self.width as usize
            + z as usize * self.width as usize * self.height as usize;

        Some(idx)
    }
}


========================================
PLIK: ./brain/src/machines/mod.rs
========================================
pub mod chest;
pub mod furnace;


========================================
PLIK: ./brain/src/machines/chest.rs
========================================
use crate::{block_entity::BlockEntity, constants::PROP_ITEM_COUNT, utils::is_int_positive};

pub struct Chest {
    pub inv_size: u16,
}

impl BlockEntity for Chest {
    fn get_int(&self, id: u16) -> Option<i32> {
        match id {
            PROP_ITEM_COUNT => Some(self.inv_size as i32),
            _ => None,
        }
    }

    fn set_int(&mut self, id: u16, value: i32) {
        match id {
            PROP_ITEM_COUNT if is_int_positive(value) => self.inv_size = value as u16,
            _ => {}
        }
    }
}


========================================
PLIK: ./brain/src/machines/furnace.rs
========================================
use crate::{
    block_entity::BlockEntity,
    constants::{PROP_FUEL_LEVEL, PROP_IS_ACTIVE, PROP_MAX_FUEL},
    utils::is_int_boolean,
};

pub struct Furnace {
    pub fuel_level: f32,
    pub max_fuel_level: f32,
}

impl BlockEntity for Furnace {
    fn get_float(&self, id: u16) -> Option<f32> {
        match id {
            PROP_FUEL_LEVEL => Some(self.fuel_level),
            PROP_MAX_FUEL => Some(self.max_fuel_level),
            _ => None,
        }
    }

    fn get_int(&self, id: u16) -> Option<i32> {
        match id {
            PROP_IS_ACTIVE if self.fuel_level != 0.0 => Some(1),
            _ => None,
        }
    }

    fn set_float(&mut self, id: u16, value: f32) {
        match id {
            PROP_FUEL_LEVEL => self.fuel_level = value,
            PROP_MAX_FUEL => self.max_fuel_level = value,
            _ => {}
        }
    }

    fn tick(&mut self) {
        if self.fuel_level > 0.0 {
            self.fuel_level -= 0.1;
        }
    }
}


========================================
PLIK: ./brain/src/constants.rs
========================================
// Floaty (Wartości ciągłe)
pub const PROP_FUEL_LEVEL: u16 = 1;
pub const PROP_MAX_FUEL: u16 = 2;

// Inty (Wartości dyskretne / stany)
pub const PROP_IS_ACTIVE: u16 = 100;
pub const PROP_ITEM_COUNT: u16 = 101;


========================================
PLIK: ./TODO.md
========================================
# ColonyCore 3D – Micro-Milestones

## M0: Setup & Handshake (Konsola, bez grafiki)
*Cel: Sprawienie, by C# i Rust w ogóle ze sobą rozmawiały. Jeśli to nie zadziała, dalsza praca nie ma sensu.*

### M0.1: Rust Library
- [x] Stwórz nowy projekt Rust: `cargo new --lib colony_core`.
- [x] W `Cargo.toml` ustaw typ crate'a: `crate-type = ["cdylib"]`.
- [x] Napisz funkcję `add(a, b)`:
    - Musi być publiczna (`pub`).
    - Musi mieć `extern "C"`.
    - Musi mieć `#[no_mangle]`.
- [x] Zbuduj projekt: `cargo build`. Sprawdź, czy masz plik `.dll` (Windows) w folderze `target/debug`.

### M0.2: C# Host
- [x] Stwórz projekt konsolowy C# (.NET 8/9).
- [x] Skopiuj `.dll` z Rusta do folderu, gdzie buduje się C# (np. `bin/Debug/net8.0`) – **automatyzacja tego to Twój przyjaciel (Post-Build Event)**.
- [x] Napisz klasę `NativeLib` z `[DllImport("colony_core.dll")]` dla funkcji `add`.
- [x] Wywołaj funkcję w `Main`. Wypisz wynik na konsolę.
- [x] **Sanity Check:** Czy `Console.WriteLine` pokazuje poprawny wynik dodawania?

### M0.3: Pamięć i Wskaźniki
- [x] W Rust: Stwórz struct `GameState { ticks: u32 }`.
- [x] W Rust: Napisz funkcję `init_game() -> *mut GameState`, która alokuje struct na stercie (`Box::new`) i zwraca wskaźnik (`Box::into_raw`).
- [x] W C#: Odbierz ten wskaźnik jako `IntPtr`.
- [x] W Rust: Napisz funkcję `get_ticks(ptr: *mut GameState) -> u32`.
- [x] W C#: Wywołaj `get_ticks` w pętli `while(true)`, przekazując wskaźnik.
- [x] **Sanity Check:** Czy licznik rośnie, a aplikacja nie wywala się z "Access Violation"?

---

## M1: Pierwsze Piksele (Hello Triangle)
*Cel: Uruchomienie OpenGL. To najtrudniejszy etap "setupowy". Po nim będzie z górki.*

### M1.1: Okno Silk.NET
- [x] Dodaj NuGety: `Silk.NET.OpenGL`, `Silk.NET.Windowing`, `Silk.NET.Input`.
- [x] Skopiuj boilerplate do stworzenia okna z dokumentacji Silk.NET.
- [x] Ustaw kolor tła (`gl.ClearColor`) na np. "Cornflower Blue" (taki ładny fioletowo-niebieski).
- [x] **Sanity Check:** Czy po odpaleniu masz kolorowe okno, które można zamknąć krzyżykiem?

### M1.2: Shadery (Kopiuj-Wklej)
- [x] Stwórz plik `shader.vert` (prosty GLSL, przekazuje pozycję).
- [x] Stwórz plik `shader.frag` (prosty GLSL, zwraca stały kolor, np. biały).
- [x] Napisz w C# klasę `Shader` (ładowanie tekstu z pliku -> kompilacja -> linkowanie programu). To jest nudne, możesz skopiować gotowca z tutoriali Silk.NET.

### M1.3: Trójkąt
- [x] Zdefiniuj tablicę `float[] vertices` dla jednego trójkąta.
- [x] Utwórz VAO (Vertex Array Object) i VBO (Vertex Buffer Object).
- [x] W pętli `OnRender`: `shader.Use()`, `vao.Bind()`, `gl.DrawArrays()`.
- [x] **Sanity Check:** Widzisz biały trójkąt na niebieskim tle? Gratulacje, masz silnik graficzny.

### M1.4: ImGui (Must Have)
- [x] Dodaj `Silk.NET.OpenGL.Extensions.ImGui`.
- [x] Zainicjalizuj kontroler ImGui.
- [x] W pętli renderowania dodaj `ImGui.Begin("Debug")`, `ImGui.Text("FPS: " + fps)`, `ImGui.End()`.
- [x] **Sanity Check:** Czy masz małe okienko z tekstem nad swoim trójkątem?

---

## M2: Voxel World (To na co czekasz)
*Cel: Zamiast trójkąta, rysujemy świat gry z Rusta.*

### M2.1: Model Sześcianu
- [x] Zmień dane wierzchołków z trójkąta na sześcian (Cube).
- [x] Użyj `glDrawElements` (EBO - Element Buffer Object), żeby nie powtarzać wierzchołków.
- [x] Dodaj macierze transformacji w C# (`Matrix4x4.CreatePerspective...`, `CreateLookAt...`).
- [x] Prześlij macierze do shadera jako `Uniform`.
- [x] **Sanity Check:** Widzisz obracający się sześcian 3D?

### M2.2: Płaski Świat w Rust
- [x] W Rust: Stwórz `Vec<BlockType>` o rozmiarze np. 16x16. Wypełnij losowymi danymi.
- [x] W Rust: Eksportuj funkcję `get_map_ptr()` i `get_map_len()`.

### M2.3: Instanced Rendering (Big Boss)
- [x] W C#: Zmień `glDrawElements` na `glDrawElementsInstanced`.
- [x] Stwórz drugi VBO (Instance VBO) trzymający pozycje (X, Y, Z) dla każdej instancji.
- [x] W `OnRender`: Pobierz wskaźnik z Rusta, skopiuj dane do Instance VBO (`glBufferSubData`).
- [x] W Vertex Shader: Dodaj `layout (location = 1) in vec3 aInstancePos` i dodaj to do pozycji wierzchołka.
- [x] **Sanity Check:** Widzisz siatkę 16x16 sześcianów? Wygląda jak podłoga?

### M2.4: Izometria
- [x] Zmień macierz projekcji z Perspective na Orthographic.
- [x] Ustaw kamerę pod kątem (np. 45 stopni w dół, 45 w bok).
- [x] **Sanity Check:** Wygląda jak klasyczny RPG/RTS?

---

## M3: Interakcja (Myszka)
*Cel: Klikanie w klocki.*

### M3.1: Kamera Ruchoma
- [x] Obsłuż zdarzenia klawiatury (WSAD) w C#.
- [x] Aktualizuj pozycję kamery ("Eye") w macierzy View.
- [x] **Sanity Check:** Możesz "latać" nad mapą?

### M3.2: Raycast Math
- [ ] Pobierz pozycję myszy (X, Y) z okna.
- [ ] Przekształć ją na "Ray World Direction" (korzystając z odwrotności macierzy). Wyświetl wartości w ImGui.
- [ ] **Sanity Check:** Gdy ruszasz myszką, wartości wektora w ImGui się zmieniają sensownie?

### M3.3: Integracja
- [ ] Prześlij Origin i Direction kamery do Rusta.
- [ ] W Rust: Napisz prostą pętlę sprawdzającą kolizję z podłogą (na razie brute-force lub proste `if z == 0`).
- [ ] W C#: Narysuj "Wireframe Cube" (ramkę) w miejscu, które zwrócił Rust.
- [ ] **Sanity Check:** Czy ramka "skacze" po klockach pod Twoją myszką?

---

## M4: Logika (Dopiero teraz!)
*Cel: Coś się rusza samo.*

### M4.1: Jednostka
- [ ] W Rust: Dodaj `struct Pawn { x: f32, y: f32 }`.
- [ ] W Rust: W `sim_tick` zmieniaj `x` o małą wartość (np. `0.01`).
- [ ] W C#: Pobierz listę pionków i wyrenderuj je jako inny kolor sześcianu (lub inny model).
- [ ] **Sanity Check:** Czy czerwony klocek przesuwa się powoli po mapie?

### M4.2: Game Loop
- [ ] Zaimplementuj akumulator czasu w C# (Fixed Time Step).
- [ ] Rozdziel logiczny FPS (60) od graficznego FPS (unlimited).
- [ ] **Sanity Check:** Gra działa tak samo szybko na 60 FPS i na 500 FPS?

========================================
PLIK: ./TODO-old.md
========================================
## 5. Szczegółowy Backlog Zadań (Roadmapa od 0 do MVP)

### Milestone 1: The Virtual World (Fundamenty Terenu)
*Cel: Wyświetlenie statycznego świata voxelowego w rzucie izometrycznym.*

**Core (Rust):**
- [ ] Zaimplementowanie struktury `VoxelMap` jako płaskiej tablicy 1D (`Vec<u8>`) mapującej koordynaty (x,y,z).
- [ ] Implementacja logiki dostępu do sąsiadów (`get_neighbor(x,y,z, direction)`).
- [ ] Eksport surowych danych mapy przez FFI (wskaźnik do bufora kolorów/typów bloków).

**Host (C#):**
- [ ] Implementacja **Instanced Rendering** dla sześcianów (jeden mesh kostki, tysiące instancji przesłanych w buforze).
- [ ] Implementacja kamery izometrycznej (Ortograficzna) z obsługą Zoomu (zmiana skali projekcji) i Pan (przesuwanie kamery).
- [ ] Optymalizacja renderowania: Culling (nie wysyłaj do GPU kostek, które są "powietrzem").

---

### Milestone 2: The Cursor & Interaction (Interakcja)
*Cel: Gracz może wskazać konkretny blok w przestrzeni 3D myszką.*

**Host (C#):**
- [ ] Implementacja **Raycastingu 3D**:
    - [ ] Przeliczenie pozycji myszy (Screen Space) na promień w świecie (World Space).
    - [ ] Obliczenie punktu przecięcia promienia z płaszczyzną terenu (Plane $Y=0$).
- [ ] Implementacja "Ghost Cursor": Wyświetlanie półprzezroczystej kostki w miejscu, gdzie wskazuje mysz (snapping do siatki).
- [ ] Przesyłanie zdarzeń kliknięcia (LPM/PPM) do Rusta wraz ze współrzędnymi (x,y,z).

**Core (Rust):**
- [ ] Obsługa komendy "Inspect": Po otrzymaniu koordynatów (x,y,z), zwróć typ bloku i informacje o nim (np. "Dirt Block").

---

### Milestone 3: The Colonists (Ruch i AI)
*Cel: Jednostki poruszają się inteligentnie po mapie.*

**Core (Rust):**
- [ ] **Struktura Unit:** Zdefiniowanie `struct Pawn` z unikalnym ID i pozycją (float).
- [ ] **State Machine (`Box<dyn State>`):**
    - [ ] Stworzenie traita `UnitState`.
    - [ ] Implementacja stanu `StateIdle`.
    - [ ] Implementacja stanu `StateMoving`.
- [ ] **Pathfinding (A*):**
    - [ ] Implementacja algorytmu A-Star na grafie voxelowym.
    - [ ] Uwzględnienie kolizji (nie wchodź w ściany).
- [ ] **Tick Loop:** Interpolacja ruchu jednostki w każdej klatce (przesuwanie `x,y` w stronę kolejnego punktu ścieżki).

**Host (C#):**
- [ ] Pobieranie listy jednostek (ID, Typ, X, Y, Z) co klatkę.
- [ ] Renderowanie jednostek (np. jako proste kapsułki lub inne modele) w ich aktualnych pozycjach.
- [ ] Interpolacja wizualna (Smoothing): Jeśli tick Rusta jest rzadszy niż FPS C#, wygładzaj ruch między klatkami.

---

### Milestone 4: The Job System (System Pracy - Serce Gry)
*Cel: Jednostki same szukają zadań (np. zetnij drzewo) i je wykonują.*

**Core (Rust):**
- [ ] **Global Job Queue:** Kolejka dostępnych zadań (np. `JobType::CutTree`).
- [ ] **Job Definition (`Rc`):**
    - [ ] Stworzenie definicji zadań (czas trwania, wymagane narzędzie).
    - [ ] Użycie `Rc` do współdzielenia tych definicji między tysiącami instancji zadań.
- [ ] **AI Decision:** Logika "Brain" dla osadnika:
    - [ ] *Czy jestem bezrobotny?* -> Sprawdź kolejkę zadań.
    - [ ] *Czy zadanie jest osiągalne?* -> Sprawdź Pathfinding.
    - [ ] *Zarezerwuj zadanie* -> Przypisz do siebie, usuń z kolejki globalnej.
- [ ] **Action Execution:** Implementacja stanu `StateWorking` (pasek postępu pracy).

**Host (C#):**
- [ ] UI: Wyświetlanie paska postępu nad głową jednostki, gdy jest w stanie `StateWorking`.
- [ ] UI: Menu kontekstowe (Prawy przycisk na drzewo -> "Mark for harvest").

---

### Milestone 5: Mining & Building (Modyfikacja Świata)
*Cel: Gracz i jednostki mogą zmieniać strukturę mapy.*

**Core (Rust):**
- [ ] **Modyfikacja VoxelMap:** Funkcja zmieniająca typ bloku w (x,y,z) np. z `Stone` na `Air` (kopanie) lub z `Air` na `Wall` (budowanie).
- [ ] **Dirty Flag:** Oznaczanie chunka mapy jako "zmieniony", aby C# wiedział, że musi odświeżyć grafikę.
- [ ] **Pathfinding Recalculation:** Jeśli postawiono ścianę, jednostki muszą przeliczyć ścieżki.

**Host (C#):**
- [ ] Obsługa "Dirty Chunk": Jeśli Rust zgłosi zmianę, przebuduj bufory instancji dla danego fragmentu mapy.
- [ ] System "Designations": Wizualne oznaczanie bloków do wykopania (np. czerwona nakładka na blokach).

---

### Milestone 6: Needs & Survival (Zarządzanie Zasobami)
*Cel: Jednostki muszą jeść i spać.*

**Core (Rust):**
- [ ] **Need System:** Struktura trzymająca paski potrzeb (Głód, Energia, Komfort).
- [ ] **Resource Inventory:** Globalny magazyn surowców (Drewno, Jedzenie) zabezpieczony przez `Arc<Mutex<Inventory>>`.
- [ ] **AI Override:** Jeśli `Hunger < 10%`, przerwij pracę i szukaj jedzenia.
- [ ] **Item Hauling:** Zadanie przenoszenia surowców z ziemi do magazynu.

**Host (C#):**
- [ ] GUI: Panel boczny wyświetlający statystyki wybranego osadnika (Wykresy głodu/energii).
- [ ] GUI: Wyświetlanie surowców leżących na ziemi (małe modele 'lootu').

---

### Milestone 7: Optimization (Zaawansowane)
*Cel: Obsługa 100x100x20 świata i 100 jednostek w 60 FPS.*

**Core (Rust):**
- [ ] **Multithreading:** Przeniesienie Pathfindingu do `ThreadPool` (Rust: `rayon` lub `std::thread`).
- [ ] **Spatial Partitioning:** Użycie Octree lub Grid Partitioning do szybszego wyszukiwania sąsiadów/kolizji.

**Host (C#):**
- [ ] **Greedy Meshing:** Łączenie sąsiadujących ścian tego samego typu w jeden duży prostokąt, aby zmniejszyć liczbę wierzchołków.
- [ ] **Texture Atlases:** Użycie jednej dużej tekstury dla wszystkich bloków.

========================================
PLIK: ./README.md
========================================
# ColonyCore 3D – Specyfikacja Techniczna Projektu

## 1. Założenia Architektoniczne
Projekt to symulator kolonii w rzucie izometrycznym. Aplikacja podzielona jest na dwie warstwy działające w jednej przestrzeni pamięci procesora.

* **CORE (Rust):** "Mózg". Odpowiada za stan świata, logikę, pathfinding i zarządzanie pamięcią. Nie posiada zależności do bibliotek graficznych.
* **HOST (C#):** "Ciało". Odpowiada za okno systemowe, wejście (mysz/klawiatura), renderowanie grafiki (OpenGL/Vulkan) i UI.

### Model Pamięci
* Rust zarządza alokacją i zwalnianiem pamięci świata gry.
* C# otrzymuje jedynie wskaźniki (`IntPtr` / `unsafe pointer`) do danych Rusta.
* **Zasada Zero-Copy:** C# nigdy nie kopiuje całych tablic danych (np. mapy), czyta je bezpośrednio z pamięci Rusta przy użyciu `Span<T>`.

---

## 2. Moduł CORE (Rust) – "Mózg"

Tutaj piszemy czystą logikę. Ten kod nie wie, że istnieje ekran, karta graficzna czy klawiatura.

### 2.1 Zarządzanie Pamięcią i Struktury
Celujemy w **Zero-Cost Abstractions**.

#### A. Struktura Świata (The World)
* **Struktura:** `SimulationContext`
* **Safety:** Używamy `Arc<RwLock<World>>`.
* **Cel:** Nawet pisząc własny silnik, warto oddzielić wątek renderowania (C#) od wątku symulacji (Rust). `RwLock` pozwoli Ci bezpiecznie robić snapshoty danych do rysowania w trakcie trwania obliczeń.

#### B. Płaska struktura danych (Data-Oriented Design)
Zamiast trzymać obiekty rozsiane po pamięci, w podejściu "low-level" warto trzymać je w wektorach.
* **Mapa:** `Vec<Tile>` (jednowymiarowa tablica reprezentująca grid 2D: `index = y * width + x`). To jest drastycznie szybsze dla procesora (CPU Cache) niż tablice tablic.
* **Jednostki:** `Vec<Pawn>`.

#### C. System Zadań (Jobs)
* **Typ:** `Rc<JobDefinition>` (jeśli symulacja jest jednowątkowa) lub `Arc<JobDefinition>` (jeśli wielowątkowa).
* **Zasada:** Definicje zadań ("Zetnij", "Buduj") są ładowane raz przy starcie i są tylko do odczytu (static data). Jednostki odnoszą się do nich przez wskaźnik.

### 2.2 Główna Pętla (The Tick)
Funkcja `update` wykonuje jeden krok dyskretny.
1.  **Logika:** A* Pathfinding (na spłaszczonym wektorze mapy).
2.  **Stan:** Aktualizacja maszyn stanów (State Machine) jednostek.
3.  **Snapshotting (Opcjonalne, ale zalecane):** Przygotowanie bufora danych dla renderera, aby C# nie musiał skakać po całej pamięci Rusta.

---

## 3. Moduł HOST (C# + Silk.NET) – "Silnik"

Tutaj budujesz fundamenty silnika gry. Będziesz musiał ręcznie obsłużyć OpenGL.

### 3.1 Stack Technologiczny
* **Silk.NET.OpenGL:** Nowoczesny, bardzo chudy wrapper na OpenGL (lżejszy niż OpenTK).
* **Silk.NET.Windowing:** Do stworzenia okna i obsługi kontekstu.
* **ImGui.NET:** Gorąco rekomenduję zintegrować to od razu. Własny silnik bez UI do debugowania to koszmar.

### 3.2 Pipeline Graficzny (To musisz napisać sam)

#### A. Shadery (GLSL)
Będziesz potrzebować dwóch prostych programów:
* **Vertex Shader:** Przymuje pozycję wierzchołka (lokalną) + pozycję instancji (ze świata). Mnoży to przez macierze MVP (Model-View-Projection).
* **Fragment Shader:** Ustala kolor piksela.

#### B. Instanced Rendering (Klucz do wydajności)
To jest najważniejszy punkt w silniku klockowym.
* **Nie rób:** `foreach (cube) { DrawCube(); }` – to "zabije" CPU (tysiące draw calls).
* **Zrób:** **Instancing**.
    1.  Wgrywasz model sześcianu do GPU **raz** (VBO - Vertex Buffer Object).
    2.  Tworzysz drugi bufor (Instance VBO) z pozycjami (x,y,z) i kolorami wszystkich 10,000 obiektów.
    3.  Wywołujesz `glDrawElementsInstanced` **raz**. Karta graficzna narysuje cały świat w jednym rzucie.

### 3.3 Kamera Matematyczna
Musisz ręcznie zbudować macierze (używając `System.Numerics.Matrix4x4`).
* **Projection:** `Matrix4x4.CreateOrthographic(...)`.
* **View:** `Matrix4x4.CreateLookAt(...)`.
    * Pozycja kamery: np. `(100, 100, 100)`
    * Cel: `(0, 0, 0)`
    * Góra: `(0, 1, 0)`
* **Model:** Macierz transformacji dla każdego sześcianu (często wystarczy tylko wektor przesunięcia w shaderze dla optymalizacji).

---

## 4. Interfejs FFI (Most)

Ponieważ piszesz "bare metal", musisz bardzo uważać na wskaźniki.

### 4.1 4.1 Struktury Danych (DTO)
Struktura przesyłana do GPU musi mieć identyczny układ w pamięci w obu językach.

**Rust (Core):**
```rust
#[repr(C)]
pub struct RenderEntity {
    pub pos_x: f32,
    pub pos_y: f32, // Wysokość
    pub pos_z: f32,
    pub color_pack: u32, // Spakowany kolor RGBA (4 bajty)
}
```

**C# (Engine):**
```csharp
[StructLayout(LayoutKind.Sequential)]
public struct RenderEntity {
    public float X;
    public float Y;
    public float Z;
    public uint Color;
}
```

### 4.2 Eksportowane API (Rust)
| Funkcja | Sygnatura | Opis |
| :--- | :--- | :--- |
| `sim_create` | `(w, h) -> *mut void` | Inicjalizuje świat i zwraca wskaźnik. |
| `sim_tick` | `(ctx, dt)` | Wykonuje krok symulacji. |
| `sim_get_render_len` | `(ctx) -> usize` | Zwraca liczbę obiektów do narysowania. |
| `sim_get_render_ptr` | `(ctx) -> *const RenderEntity` | Zwraca wskaźnik do tablicy obiektów. |

### 4.3 Pętla Renderowania (C# Pseudokod)
```csharp
protected override void OnRender(double delta) {
    // 1. Logika (Rust)
    NativeLib.sim_tick(_simHandle, (float)delta);

    // 2. Pobranie danych
    var count = NativeLib.sim_get_render_len(_simHandle);
    var ptr = NativeLib.sim_get_render_ptr(_simHandle);

    // 3. Transfer do GPU (Zero-GC)
    // Bezpośrednie kopiowanie pamięci z Rusta do bufora OpenGL
    _gl.BindBuffer(BufferTargetARB.ArrayBuffer, _instanceBuffer);
    _gl.BufferSubData(BufferTargetARB.ArrayBuffer, 0, (nuint)(count * sizeof(RenderEntity)), ptr);

    // 4. Rysowanie
    _gl.UseProgram(_shaderProgram);
    // ... bind textures / uniforms ...
    _gl.DrawElementsInstanced(PrimitiveType.Triangles, _indicesCount, DrawElementsType.UnsignedInt, null, (uint)count);
}
```

---

## 5. Interakcja: Raycasting i Mouse Picking
W grze izometrycznej/3D najtrudniejszym elementem UX jest to, że myszka porusza się po płaszczyźnie ekranu (2D), a Ty musisz precyzyjnie wskazać konkretny sześcian (lub ścianę sześcianu) w przestrzeni 3D.

### 5.1 Matematyka Unprojection (C# Host)
Host musi zamienić koordynaty kursora myszy (x, y) na promień (Ray) w świecie gry. Jest to doskonałe ćwiczenie z algebry liniowej.
1.  **Normalizacja (NDC):** Zamień pozycję myszy na zakres [-1, 1].
2.  **Odwrócenie Macierzy:** Użyj odwrotności macierzy View i Projection: `P_world = Inverse(M_proj * M_view) * P_ndc`.
3.  **Ray Origin & Direction:** Obliczasz punkt startowy (kamera) i wektor kierunkowy. Te dane (6 floatów) przesyłasz do Rusta przez FFI.

### 5.2 Voxel Traversal (Rust Core)
Nie używaj prostej kolizji ze wszystkimi obiektami (to za wolne i nieedukacyjne). Ponieważ Twój świat to grid (siatka), użyj algorytmu **DDA (Digital Differential Analyzer)** lub "Fast Voxel Traversal Algorithm" (Amanatides & Woo). To standard w silnikach voxelowych.

**API FFI (Rust):**
```rust
#[no_mangle]
pub extern "C" fn sim_raycast(
    ctx: *mut SimulationContext, 
    ray_origin_x: f32, ray_origin_y: f32, ray_origin_z: f32,
    ray_dir_x: f32, ray_dir_y: f32, ray_dir_z: f32
) -> RaycastResult {
    // Algorytm "kroczy" po siatce voxeli wzdłuż promienia.
    // Zwraca koordynaty pierwszego napotkanego nie-pustego bloku
    // ORAZ normalną ściany (żeby wiedzieć, czy budujemy "na", czy "obok").
}
```

### 5.3 Selekcja i Gizmo
Host (C#) po otrzymaniu wyniku z Rusta musi narysować "ducha" (ghost object) lub ramkę selekcji (wireframe cube) w miejscu wskazanym przez `RaycastResult`. To daje graczowi natychmiastowy feedback.

---

## 6. Architektura Pętli Czasu (Game Loop)
RimWorld jest deterministyczny. Oznacza to, że przy tych samych danych wejściowych, symulacja zawsze przebiegnie tak samo. Wymaga to **rozdzielenia czasu renderowania od czasu symulacji**. To jedno z najważniejszych zagadnień w inżynierii silników gier.

### 6.1 Fixed Time Step (Akumulator)
Renderowanie (C#) może działać w 144 FPS lub 30 FPS, ale fizyka/logika kolonii (Rust) musi działać zawsze stałym tempie, np. 60 Tickach na sekundę (TPS).

**Algorytm w C# (Główna pętla):**
```csharp
double accumulator = 0.0;
double dt = 1.0 / 60.0; // Stały krok symulacji (16.6ms)

void OnUpdate(double deltaRender) {
    accumulator += deltaRender;

    // Pętla "doganiająca" symulację (Decoupled sim speed from frame rate)
    // Jeśli gra zwolni (lag), ta pętla wykona się kilka razy,
    // aby logika gry "dogoniła" czas rzeczywisty.
    while (accumulator >= dt) {
        NativeLib.sim_tick(_simHandle, dt); // Rust liczy logiczny krok
        accumulator -= dt;
    }

    // Renderowanie z interpolacją
    // alpha mówi nam, w którym momencie "pomiędzy" tickami fizyki jesteśmy (0.0 - 1.0)
    double alpha = accumulator / dt; 
    RenderWorld(alpha); 
}
```

### 6.2 Interpolacja Stanu (Render State)
Aby ruch jednostek był płynny przy Fixed Time Step (szczególnie przy monitorach o wysokim odświeżaniu), nie możesz po prostu rysować `Position`.
Rust powinien zwracać dwie pozycje dla każdego obiektu:
1.  `PreviousPosition` (z poprzedniego ticka)
2.  `CurrentPosition` (z obecnego ticka)

Shader w C# (lub logika przed wysłaniem do GPU) wylicza pozycję wizualną:
`Pos_visual = Lerp(Pos_prev, Pos_current, alpha)`

Bez tego mechanizmu ruch kamery i jednostek będzie szarpał (jitter), nawet przy wysokim FPS.